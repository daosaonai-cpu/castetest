<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NIELIT KOKRAJHAR EC AI Smart Class Env.</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        /* Custom styles for the loader, layout, and new UI elements */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .input_video {
            display: none;
        }
        #output_canvas {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Use contain to see the whole page */
        }
        .mirrored {
            transform: scaleX(-1); /* Mirror effect */
        }
        /* Style for disabled buttons */
        .disabled-button {
            background-color: #a0aec0; /* gray-500 */
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* Style for notifications */
        #notification-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(239, 68, 68, 0.8); /* red-500 with opacity */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #notification-container.show {
            opacity: 1;
            visibility: visible;
        }
        /* Fullscreen style for the container */
        #container.fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            z-index: 50;
            background-color: #111827; /* bg-gray-900 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-blue-400">NIELIT KOKRAJHAR EC AI Smart Class Env.</h1>
        <p class="text-center text-gray-400 mb-6">BANAJIT BORO</p>

        <!-- Main container for the video feed and loader -->
        <div id="container" class="relative w-full aspect-video rounded-lg shadow-2xl bg-gray-800 flex items-center justify-center overflow-hidden">
            <canvas id="output_canvas" class="absolute top-0 left-0"></canvas>
            <video class="input_video" id="input_video" autoplay playsinline></video>
            <div id="loading-indicator" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-800 bg-opacity-75 rounded-lg z-10">
                <div class="loader"></div>
                <p class="mt-4 text-lg">Initializing Camera...</p>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="mt-4 flex justify-center items-center flex-wrap gap-4">
            <button id="clear-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">
                Clear All
            </button>
            <button id="fullscreen-button" class="hidden bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">
                Fullscreen
            </button>
            <input type="file" id="file-upload" class="hidden" accept="image/*,application/pdf">
            <label for="file-upload" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors cursor-pointer">
                Upload File
            </label>
            <!-- PDF Navigation -->
            <button id="prev-page-button" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">Prev</button>
            <span id="page-indicator" class="hidden text-lg"></span>
            <button id="next-page-button" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">Next</button>
        </div>
    </div>

    <!-- Notification container -->
    <div id="notification-container"></div>

    <script type="module">
        // Set the workerSrc for PDF.js
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;

        // --- Get references to the HTML elements ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingIndicator = document.getElementById('loading-indicator');
        const clearButton = document.getElementById('clear-button');
        const fileUploadInput = document.getElementById('file-upload');
        const prevPageButton = document.getElementById('prev-page-button');
        const nextPageButton = document.getElementById('next-page-button');
        const pageIndicator = document.getElementById('page-indicator');
        const notificationContainer = document.getElementById('notification-container');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const container = document.getElementById('container');


        // --- State Variables ---
        let currentMode = 'idle'; // 'idle', 'drawing', 'erasing'
        let lastMode = 'idle';
        let currentPath = [];
        let allPaths = [];
        let uploadedImage = null;
        let pdfDoc = null;
        let currentPageNum = 1;
        let totalPages = 0;
        let isFullscreen = false;
        
        // --- On-Canvas Button Control State ---
        let lastButtonPressTime = 0;
        const BUTTON_PRESS_COOLDOWN = 1000; // 1 second cooldown

        // --- Configuration ---
        const drawingColor = '#ec4899'; // Pink color
        const drawingLineWidth = 6;
        const eraserColor = 'rgba(239, 68, 68, 0.5)'; // Semi-transparent red
        const eraserRadius = 30;
        const cursorColor = '#f87171';
        const cursorRadius = 5;

        // --- UI Feedback Functions ---
        function showNotification(message, duration = 3000) {
            notificationContainer.textContent = message;
            notificationContainer.classList.add('show');
            setTimeout(() => {
                notificationContainer.classList.remove('show');
            }, duration);
        }

        // --- Fullscreen Toggle ---
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;

            container.classList.toggle('fullscreen-mode', isFullscreen);
            
            // Hide siblings of the container (title, controls, etc.)
            const siblings = [...container.parentElement.children];
            siblings.forEach(child => {
                if (child.id !== 'container') {
                    child.classList.toggle('hidden', isFullscreen);
                }
            });

            if (isFullscreen) {
                const exitButton = document.createElement('button');
                exitButton.id = 'exit-fullscreen-btn';
                exitButton.textContent = 'Exit Fullscreen (Esc)';
                exitButton.className = 'fixed top-4 right-4 z-[100] bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md';
                exitButton.onclick = toggleFullscreen;
                document.body.appendChild(exitButton);
            } else {
                const exitButton = document.getElementById('exit-fullscreen-btn');
                if (exitButton) {
                    exitButton.remove();
                }
            }
        }
        
        // --- Canvas Drawing Helper Functions ---
        function drawPaths() {
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';

            // Draw all completed paths
            for (const path of allPaths) {
                if (path.points.length < 2) continue;
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = path.color;
                canvasCtx.lineWidth = path.width;
                canvasCtx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    canvasCtx.lineTo(path.points[i].x, path.points[i].y);
                }
                canvasCtx.stroke();
            }
            // Draw the current path being drawn
            if (currentPath.length > 1) {
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = drawingColor;
                canvasCtx.lineWidth = drawingLineWidth;
                canvasCtx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    canvasCtx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                canvasCtx.stroke();
            }
        }
        
        // Helper to draw rounded rectangles for on-canvas buttons
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // --- Main Animation Loop ---
        function onResults(results) {
            if (loadingIndicator.style.display !== 'none') {
                loadingIndicator.style.display = 'none';
            }

            // Toggle mirror effect based on content type
            if (uploadedImage) {
                // Don't mirror for PDF/Image
                canvasElement.classList.remove('mirrored');
            } else {
                // Mirror for the live camera feed
                canvasElement.classList.add('mirrored');
            }

            // Set canvas dimensions
            canvasElement.width = isFullscreen ? window.innerWidth : videoElement.videoWidth;
            canvasElement.height = isFullscreen ? window.innerHeight : videoElement.videoHeight;


            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 1. Draw the background (camera feed or uploaded file)
            if (uploadedImage) {
                canvasCtx.drawImage(uploadedImage, 0, 0, canvasElement.width, canvasElement.height);
            } else {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }

            // 2. Draw user-made paths
            drawPaths();
            
            // 3. Handle hand detection and gestures
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let handLandmarks = results.multiHandLandmarks[0];

                // If viewing a PDF/image, we need to manually flip the hand coordinates
                // because the canvas itself is not mirrored, but the camera input is.
                if (uploadedImage) {
                    handLandmarks = handLandmarks.map(landmark => {
                        return { 
                            ...landmark, 
                            x: 1 - landmark.x 
                        };
                    });
                }

                handlePdfNavigation(handLandmarks);
                handleGestures(handLandmarks);

                // Draw hand landmarks for visual feedback
                window.drawConnectors(canvasCtx, handLandmarks, window.HAND_CONNECTIONS, { color: '#34d399', lineWidth: 5 });
                const landmarkColor = currentMode === 'erasing' ? '#ef4444' : (currentMode === 'drawing' ? '#ec4899' : '#f87171');
                window.drawLandmarks(canvasCtx, handLandmarks, { color: landmarkColor, lineWidth: 2 });
            } else { // Hand not detected
                if (currentMode === 'drawing') { // Finish any path if hand leaves screen
                    if (currentPath.length > 1) {
                        allPaths.push({ points: currentPath, color: drawingColor, width: drawingLineWidth });
                    }
                    currentPath = [];
                }
                currentMode = 'idle';
            }
            
            canvasCtx.restore();
        }
        
        function handlePdfNavigation(handLandmarks) {
            if (!pdfDoc) return;
            
            const buttonWidth = 120;
            const buttonHeight = 70;
            const buttonPadding = 20;
            const buttonRadius = 15;

            const prevButtonRect = { x: buttonPadding, y: buttonPadding, width: buttonWidth, height: buttonHeight };
            const nextButtonRect = { x: canvasElement.width - buttonWidth - buttonPadding, y: buttonPadding, width: buttonWidth, height: buttonHeight };
            
            const indexTip = handLandmarks[8];
            const indexTipPos = { x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height };
            const now = Date.now();
            let prevButtonHover = false;
            let nextButtonHover = false;

            // Check for Previous button touch
            if (now - lastButtonPressTime > BUTTON_PRESS_COOLDOWN &&
                indexTipPos.x > prevButtonRect.x && indexTipPos.x < prevButtonRect.x + prevButtonRect.width &&
                indexTipPos.y > prevButtonRect.y && indexTipPos.y < prevButtonRect.y + prevButtonRect.height) {
                prevButtonHover = true;
                prevPageButton.click();
                lastButtonPressTime = now;
            }

            // Check for Next button touch
            if (now - lastButtonPressTime > BUTTON_PRESS_COOLDOWN &&
                indexTipPos.x > nextButtonRect.x && indexTipPos.x < nextButtonRect.x + nextButtonRect.width &&
                indexTipPos.y > nextButtonRect.y && indexTipPos.y < nextButtonRect.y + nextButtonRect.height) {
                nextButtonHover = true;
                nextPageButton.click();
                lastButtonPressTime = now;
            }
            
            // Draw the buttons
            canvasCtx.font = 'bold 30px Inter';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';

            // Previous Button
            canvasCtx.fillStyle = prevButtonHover ? 'rgba(96, 165, 250, 0.8)' : 'rgba(96, 165, 250, 0.5)';
            drawRoundRect(canvasCtx, prevButtonRect.x, prevButtonRect.y, prevButtonRect.width, prevButtonRect.height, buttonRadius);
            canvasCtx.fillStyle = 'white';
            canvasCtx.fillText('PREV', prevButtonRect.x + prevButtonRect.width / 2, prevButtonRect.y + prevButtonRect.height / 2);
            
            // Next Button
            canvasCtx.fillStyle = nextButtonHover ? 'rgba(96, 165, 250, 0.8)' : 'rgba(96, 165, 250, 0.5)';
            drawRoundRect(canvasCtx, nextButtonRect.x, nextButtonRect.y, nextButtonRect.width, nextButtonRect.height, buttonRadius);
            canvasCtx.fillStyle = 'white';
            canvasCtx.fillText('NEXT', nextButtonRect.x + nextButtonRect.width / 2, nextButtonRect.y + nextButtonRect.height / 2);
        }

        function handleGestures(handLandmarks) {
            const indexTip = handLandmarks[8];
            const middleTip = handLandmarks[12];
            const thumbTip = handLandmarks[4];
            
            // --- Gesture Recognition Logic ---
            // Drawing: Index and middle fingertips are very close
            const drawGestureDistance = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
            const isDrawingGesture = drawGestureDistance < 0.04;
            
            // Erasing: A closed fist (all fingertips are close to the palm center)
            const isFist = (
                Math.hypot(thumbTip.x - handLandmarks[10].x, thumbTip.y - handLandmarks[10].y) < 0.1 &&
                Math.hypot(indexTip.x - handLandmarks[6].x, indexTip.y - handLandmarks[6].y) < 0.1 &&
                Math.hypot(handLandmarks[20].x - handLandmarks[14].x, handLandmarks[20].y - handLandmarks[14].y) < 0.1 // Pinky tip to middle knuckle
            );
            
            // --- Action Implementation ---
            if (isFist) {
                currentMode = 'erasing';
                if (currentMode === 'drawing' && currentPath.length > 1) { // Finish path before erasing
                     allPaths.push({ points: currentPath, color: drawingColor, width: drawingLineWidth });
                     currentPath = [];
                }

                const eraserPos = {
                    x: handLandmarks[9].x * canvasElement.width,
                    y: handLandmarks[9].y * canvasElement.height
                };
                // Draw eraser visual
                canvasCtx.fillStyle = eraserColor;
                canvasCtx.beginPath();
                canvasCtx.arc(eraserPos.x, eraserPos.y, eraserRadius, 0, 2 * Math.PI);
                canvasCtx.fill();
                // Filter out points within the eraser radius
                allPaths = allPaths.filter(path => !path.points.some(point => Math.hypot(point.x - eraserPos.x, point.y - eraserPos.y) < eraserRadius));
            } else if (isDrawingGesture) {
                currentMode = 'drawing';
                const fingerTipPos = { x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height };
                
                // Start a new path or add to the current one
                if (lastMode !== 'drawing') {
                    currentPath = [fingerTipPos];
                } else {
                    currentPath.push(fingerTipPos);
                }
            } else { // Idle mode (hand is open, not drawing, not erasing)
                currentMode = 'idle';
                // If we were just drawing, finalize the path
                if (lastMode === 'drawing') {
                    if (currentPath.length > 1) {
                        allPaths.push({ points: currentPath, color: drawingColor, width: drawingLineWidth });
                    }
                    currentPath = [];
                }
                
                // Draw a cursor at the index fingertip
                const cursorPosition = { x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height };
                canvasCtx.fillStyle = cursorColor;
                canvasCtx.beginPath();
                canvasCtx.arc(cursorPosition.x, cursorPosition.y, cursorRadius, 0, 2 * Math.PI);
                canvasCtx.fill();
            }
            lastMode = currentMode;
        }


        // --- PDF Rendering ---
        async function renderPdfPage(num) {
            if (!pdfDoc || num < 1 || num > totalPages) return;
            
            try {
                const page = await pdfDoc.getPage(num);
                const viewport = page.getViewport({ scale: 2.0 });
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.height = viewport.height;
                tempCanvas.width = viewport.width;

                await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
                
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    allPaths = []; // Clear drawings for the new page
                    currentPath = [];
                };
                img.src = tempCanvas.toDataURL();
                pageIndicator.textContent = `Page ${num} of ${totalPages}`;
                
                // Update button states
                prevPageButton.disabled = num <= 1;
                nextPageButton.disabled = num >= totalPages;
                prevPageButton.classList.toggle('disabled-button', num <= 1);
                nextPageButton.classList.toggle('disabled-button', num >= totalPages);

            } catch(error) {
                console.error("Failed to render PDF page:", error);
                showNotification("Failed to render PDF page.");
            }
        }

        // --- Initialization and Event Listeners ---
        const hands = new window.Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
            }
        });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);
        const camera = new window.Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width: 1280, height: 720 });
        camera.start();

        clearButton.addEventListener('click', () => {
            if (isFullscreen) {
                toggleFullscreen();
            }
            fullscreenButton.classList.add('hidden');
            allPaths = [];
            currentPath = [];
            uploadedImage = null; // Also clear the uploaded image background
            pdfDoc = null;
            fileUploadInput.value = ''; // Reset file input
            // Hide PDF controls
            prevPageButton.classList.add('hidden');
            nextPageButton.classList.add('hidden');
            pageIndicator.classList.add('hidden');
        });

        fileUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            fullscreenButton.classList.remove('hidden');

            // Reset drawing and PDF state
            allPaths = [];
            currentPath = [];
            pdfDoc = null;
            uploadedImage = null;

            if (file.type.startsWith('image/')) {
                // Hide PDF controls
                prevPageButton.classList.add('hidden');
                nextPageButton.classList.add('hidden');
                pageIndicator.classList.add('hidden');
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => { uploadedImage = img; };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const loadingTask = window.pdfjsLib.getDocument({ data: e.target.result });
                        const pdf = await loadingTask.promise;
                        pdfDoc = pdf;
                        totalPages = pdf.numPages;
                        currentPageNum = 1;
                        await renderPdfPage(currentPageNum);
                        // Show PDF controls
                        prevPageButton.classList.remove('hidden');
                        nextPageButton.classList.remove('hidden');
                        pageIndicator.classList.remove('hidden');
                    } catch (error) {
                        console.error('Error loading PDF:', error);
                        showNotification("Could not load the PDF file. It might be corrupted.");
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                showNotification("Unsupported file type. Please upload an image or PDF.");
            }
        });

        fullscreenButton.addEventListener('click', toggleFullscreen);

        document.addEventListener('keydown', (event) => {
            if (event.key === "Escape" && isFullscreen) {
                toggleFullscreen();
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (currentPageNum >= totalPages) return;
            currentPageNum++;
            renderPdfPage(currentPageNum);
        });

        prevPageButton.addEventListener('click', () => {
            if (currentPageNum <= 1) return;
            currentPageNum--;
            renderPdfPage(currentPageNum);
        });
    </script>
</body>
</html>











