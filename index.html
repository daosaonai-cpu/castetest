<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCA 1st Sem Notes: C Programming</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for code blocks */
        pre {
            background-color: #f3f4f6; /* gray-100 */
            border-radius: 8px; /* rounded-lg */
            padding: 16px; /* p-4 */
            overflow-x: auto; /* Allow horizontal scroll for code */
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }
        code {
            color: #1f2937; /* gray-800 */
        }
        /* Style for keywords */
        code .kw {
            color: #4f46e5; /* indigo-600 */
            font-weight: 500;
        }
        /* Style for comments */
        code .cmt {
            color: #16a34a; /* green-600 */
        }
        /* Style for strings */
        code .str {
            color: #d97706; /* amber-600 */
        }
        /* Style for numbers */
        code .num {
            color: #db2777; /* pink-600 */
        }
        .prose {
            line-height: 1.7;
        }
        .prose p {
            margin-bottom: 1em;
        }
        .prose ul {
            list-style-type: disc;
            padding-left: 1.5em;
            margin-bottom: 1em;
        }
        .prose li {
            margin-bottom: 0.5em;
        }
        .prose strong {
            color: #1f2937; /* gray-800 */
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto max-w-4xl px-4 py-8 sm:py-12">
        <!-- Header -->
        <header class="mb-10 text-center">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">BCA 1st Semester Notes</h1>
            <p class="mt-2 text-xl font-semibold text-indigo-600">Structures, Unions & Preprocessors in C</p>
        </header>

        <!-- Main Content -->
        <main class="space-y-12">

            <!-- Section: Structures -->
            <section id="structures" class="scroll-mt-20">
                <h2 class="text-2xl sm:text-3xl font-bold text-gray-900 border-b-2 border-indigo-500 pb-2 mb-6">1. Structures</h2>
                
                <div class="space-y-6">
                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is a structure in C, and why is it necessary?</h3>
                        <div class="prose text-gray-700">
                            <p>A structure is a <strong>user-defined, composite data type</strong> in C. Its primary purpose is to allow you to group multiple related data items of <strong>different types</strong> under a single name.</p>
                            <p><strong>Necessity:</strong> Primitive data types (like <code class="font-mono text-sm bg-gray-100 p-1 rounded">int</code>, <code class="font-mono text-sm bg-gray-100 p-1 rounded">float</code>, <code class="font-mono text-sm bg-gray-100 p-1 rounded">char</code>) can only store a single value. Arrays can store multiple values, but they must all be of the <strong>same type</strong> (homogeneous). Structures solve this limitation by creating a <strong>heterogeneous</strong> container. For example, to represent a "Student," you need a roll number (int), a name (array of char), and marks (float). A structure bundles these different types into a single logical unit called <code class="font-mono text-sm bg-gray-100 p-1 rounded">struct Student</code>.</p>
                        </div>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: How are structures stored in memory? (Memory Alignment & Padding)</h3>
                        <p class="text-gray-700 mb-4">Structures are not simply stored as a compact block of their members. The compiler often inserts extra empty bytes between members to ensure <strong>memory alignment</strong>. This is called <strong>padding</strong>.</p>
                        <p class="text-gray-700 mb-4"><strong>Why?</strong> CPUs can access data more efficiently when it starts at a memory address that is a multiple of its size (e.g., a 4-byte `int` is fastest to access if it starts at address 0, 4, 8, etc.).</p>
                        <pre><code><span class="kw">struct</span> Example {
    <span class="kw">char</span> a;   <span class="cmt">// 1 byte</span>
    <span class="cmt">// 3 bytes of padding might be added by the compiler</span>
    <span class="kw">int</span> b;    <span class="cmt">// 4 bytes</span>
    <span class="kw">char</span> c;   <span class="cmt">// 1 byte</span>
    <span class="cmt">// 3 bytes of padding might be added for overall alignment</span>
};
<span class="cmt">// The sizeof(struct Example) is likely 12 bytes, not 6 (1+4+1).</span></code></pre>
                        <p class="text-gray-700 mt-4">This means you cannot assume the size of a structure is the exact sum of its members' sizes. Always use the <code class="font-mono text-sm bg-gray-100 p-1 rounded">sizeof()</code> operator to find the true size of a structure.</p>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: How do you give values to (access) structure members?</h3>
                        <div class="prose text-gray-700">
                            <p>You use the <strong>dot operator</strong> (<code class="font-mono text-sm bg-gray-100 p-1 rounded">.</code>), also known as the "member access operator." This operator connects the structure variable name with the member name you wish to access.</p>
                        </div>
                        <pre><code><span class="kw">struct</span> Student s1;

<span class="cmt">// Giving values to members (Writing)</span>
s1.roll_no = <span class="num">101</span>;
strcpy(s1.name, <span class="str">"Alice"</span>); <span class="cmt">// Cannot use s1.name = "Alice" (array assignment)</span>
s1.marks = <span class="num">92.5</span>;

<span class="cmt">// Accessing/reading values (Reading)</span>
printf(<span class="str">"Roll No: %d\n"</span>, s1.roll_no);
printf(<span class="str">"Name: %s\n"</span>, s1.name);</code></pre>
                    </div>
                    
                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: How do you initialize a structure variable?</h3>
                        <div class="prose text-gray-700">
                            <p>Initialization is the process of assigning values to a structure variable at the time of its declaration. This is done using a comma-separated list of values enclosed in curly braces <code class="font-mono text-sm bg-gray-100 p-1 rounded">{}</code>.</p>
                            <p>The values in the list must correspond to the order of the members in the structure definition.</p>
                        </div>
                        <pre><code><span class="cmt">// 1. Order-based initialization</span>
<span class="kw">struct</span> Student s1 = {<span class="num">101</span>, <span class="str">"Alice"</span>, <span class="num">92.5</span>};

<span class="cmt">// 2. Designated initialization (C99 onwards)</span>
<span class="cmt">// This is safer as it doesn't depend on order.</span>
<span class="kw">struct</span> Student s2 = {
    .roll_no = <span class="num">102</span>,
    .name = <span class="str">"Bob"</span>,
    .marks = <span class="num">88.0</span>
};</code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: Can you compare two structure variables directly?</h3>
                        <div class="prose text-gray-700">
                            <p><strong>No.</strong> You cannot use relational operators like <code class="font-mono text-sm bg-gray-100 p-1 rounded">==</code> or <code class="font-mono text-sm bg-gray-100 p-1 rounded">!=</code> to compare two structure variables directly.</p>
                            <p><strong>Reason:</strong> A structure variable represents a block of memory. This block might contain "padding bytes" inserted by the compiler for data alignment. A direct <code class="font-mono text-sm bg-gray-100 p-1 rounded">==</code> comparison would be a bitwise comparison of this entire memory block, including the unpredictable padding bytes. This could result in two structures being reported as "not equal" even if all their members are identical.</p>
                            <p><strong>Solution:</strong> You must write a function (or inline code) to compare the structures <strong>member by member</strong>.</p>
                        </div>
                        <pre><code><span class="kw">struct</span> Student s1 = {<span class="num">101</span>, <span class="str">"Alice"</span>, <span class="num">92.5</span>};
<span class="kw">struct</span> Student s2 = {<span class="num">101</span>, <span class="str">"Alice"</span>, <span class="num">92.5</span>};

<span class="cmt">// if (s1 == s2) { ... }  // COMPILE ERROR</span>

<span class="cmt">// Correct way: compare member by member</span>
<span class="kw">if</span> (s1.roll_no == s2.roll_no && 
    strcmp(s1.name, s2.name) == <span class="num">0</span> && <span class="cmt">// Use strcmp for strings</span>
    s1.marks == s2.marks) 
{
    printf(<span class="str">"The records are identical.\n"</span>);
}</code></pre>
                        <p class="prose text-gray-700 mt-4"><strong>Note:</strong> You <strong>can</strong> assign one structure to another using the <code class="font-mono text-sm bg-gray-100 p-1 rounded">=</code> operator (e.g., <code class="font-mono text-sm bg-gray-100 p-1 rounded">s2 = s1;</code>). This performs a member-by-member copy of the values.</p>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is an array of structures?</h3>
                        <div class="prose text-gray-700">
                            <p>An array of structures is a data structure that groups multiple records of the same structure type. If <code class="font-mono text-sm bg-gray-100 p-1 rounded">struct Student</code> is a blueprint for one student, an <code class="font-mono text-sm bg-gray-100 p-1 rounded">struct Student[60]</code> is an array to hold the records for an entire class of 60 students.</p>
                            <p>In memory, this is represented as a contiguous block of memory, where each element is a complete structure.</p>
                        </div>
                        <pre><code><span class="cmt">// An array to hold records for 60 students</span>
<span class="kw">struct</span> Student bca_class[<span class="num">60</span>];

<span class="cmt">// Accessing the first student's (index 0) roll number</span>
bca_class[<span class="num">0</span>].roll_no = <span class="num">101</span>;

<span class="cmt">// Accessing the 10th student's (index 9) name</span>
strcpy(bca_class[<span class="num">9</span>].name, <span class="str">"Charlie"</span>);</code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is an array within a structure?</h3>
                        <div class="prose text-gray-700">
                            <p>This refers to a structure definition where one or more of its members is an array. This is a fundamental part of data modeling. For example, a student's name is not a single character but a sequence of characters, so it is declared as a <code class="font-mono text-sm bg-gray-100 p-1 rounded">char</code> array within the structure. Similarly, a student might have marks in multiple subjects, which can be stored as an array of <code class="font-mono text-sm bg-gray-100 p-1 rounded">int</code> or <code class="font-mono text-sm bg-gray-100 p-1 rounded">float</code>.</p>
                        </div>
                        <pre><code><span class="kw">struct</span> Student {
    <span class="kw">int</span> roll_no;
    <span class="kw">char</span> name[<span class="num">50</span>];         <span class="cmt">// Array within structure</span>
    <span class="kw">int</span> subject_marks[<span class="num">5</span>];  <span class="cmt">// Another array within structure</span>
};

<span class="kw">struct</span> Student s1;
<span class="cmt">// Accessing the mark for the 1st subject (index 0)</span>
s1.subject_marks[<span class="num">0</span>] = <span class="num">95</span>;</code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is a structure within a structure (nested structure)?</h3>
                        <div class="prose text-gray-700">
                            <p>Nesting is the concept of using one structure type as a member inside another structure definition. This allows you to create complex, hierarchical data models that more accurately represent real-world relationships. For example, a "Student" record might contain a "Date of Birth," which is itself a structure with day, month, and year members. This is logically cleaner than having <code class="font-mono text-sm bg-gray-100 p-1 rounded">dob_day</code>, <code class="font-mono text-sm bg-gray-100 p-1 rounded">dob_month</code>, and <code class="font-mono text-sm bg-gray-100 p-1 rounded">dob_year</code> as separate members directly in the <code class="font-mono text-sm bg-gray-100 p-1 rounded">Student</code> structure.</p>
                            <p>To access the members of the inner structure, you "chain" the dot operator.</p>
                        </div>
                        <pre><code><span class="cmt">// Define a Date structure first</span>
<span class="kw">struct</span> Date {
    <span class="kw">int</span> day;
    <span class="kw">int</span> month;
    <span class="kw">int</span> year;
};

<span class="cmt">// Use the Date structure inside the Student structure</span>
<span class="kw">struct</span> Student {
    <span class="kw">int</span> roll_no;
    <span class="kw">char</span> name[<span class="num">50</span>];
    <span class="kw">struct</span> Date dob;  <span class="cmt">// Nesting</span>
};

<span class="kw">struct</span> Student s1;
<span class="cmt">// Accessing nested members (chaining the dot operator)</span>
s1.dob.day = <span class="num">15</span>;
s1.dob.month = <span class="num">6</span>;
s1.dob.year = <span class="num">2005</span>;</code></pre>
                        <p class="text-gray-700 mb-2 mt-4"><strong>2. Passing by Reference (using Pointers):</strong> The address of the structure is passed. This is much more efficient (no copying a large structure) and allows the function to modify the original structure.</p>
                        <p class="text-gray-700 mb-4">When you have a <strong>pointer</strong> to a structure, you cannot use the dot operator (<code class="font-mono text-sm bg-gray-100 p-1 rounded">.</code>) directly. You must first dereference the pointer with <code class="font-mono text-sm bg-gray-100 p-1 rounded">*</code> and then use the dot operator. C provides a shortcut for this: the <strong>arrow operator</strong> (<code class="font-mono text-sm bg-gray-100 p-1 rounded">-></code>).</p>
                        <pre><code><span class="kw">void</span> updateMarks(<span class="kw">struct</span> Student *s_ptr) { <span class="cmt">// Pass by reference</span>
    <span class="cmt">// Long way: (*s_ptr).marks = 95.0;</span>
    <span class="cmt">// Short way (preferred):</span>
    s_ptr->marks = <span class="num">95.0</span>; <span class="cmt">// This modifies the original s1</span>
    strcpy(s_ptr->name, <span class="str">"Alicia"</span>); <span class="cmt">// Also modifies the original</span>
}
<span class="cmt">// In main: updateMarks(&s1); // Pass the address</span></code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is `typedef` and how is it used with structures?</h3>
                        <p class="text-gray-700 mb-4"><code class="font-mono text-sm bg-gray-100 p-1 rounded">typedef</code> is a keyword in C that allows you to create an <strong>alias</strong> or a new name for an existing data type. It is very commonly used with structures to create a simpler, cleaner type name.</p>
                        <p class="text-gray-700 mb-4">It lets you avoid writing <code class="font-mono text-sm bg-gray-100 p-1 rounded">struct Student</code> every time you want to declare a variable. You can just write <code class="font-mono text-sm bg-gray-100 p-1 rounded">Student</code>.</p>
                        <pre><code><span class="cmt">// 1. Define the struct AND create a typedef</span>
<span class="kw">typedef struct</span> StudentNode {
    <span class="kw">int</span> roll_no;
    <span class="kw">char</span> name[<span class="num">50</span>];
    <span class="kw">float</span> marks;
} Student; <span class="cmt">// 'Student' is now the new alias for 'struct StudentNode'</span>

<span class="cmt">// 2. Now, variable declaration is much cleaner:</span>
<span class="kw">int</span> main() {
    <span class="cmt">// Instead of: struct StudentNode s1;</span>
    Student s1; <span class="cmt">// This is much easier to read!</span>
    
    s1.roll_no = <span class="num">101</span>;
    <span class="kw">return</span> <span class="num">0</span>;
}</code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is a self-referential structure?</h3>
                        <p class="text-gray-700 mb-4">A self-referential structure is a structure that contains a <strong>pointer to itself</strong> (i.e., a pointer to a structure of the same type). This concept is the fundamental building block for dynamic data structures like <strong>linked lists</strong>, trees, and graphs.</p>
                        <pre><code><span class="cmt">// Using typedef for clarity</span>
<span class="kw">typedef struct</span> Node {
    <span class="kw">int</span> data;
    <span class="kw">struct</span> Node *next; <span class="cmt">// Pointer to another 'Node' structure</span>
} Node;

<span class="cmt">// This allows you to chain nodes together:</span>
<span class="cmt">// [ Node 1 ] -> [ Node 2 ] -> [ Node 3 ] -> NULL</span>

Node n1, n2;
n1.data = <span class="num">10</span>;
n2.data = <span class="num">20</span>;
n1.next = &n2; <span class="cmt">// n1 points to n2</span>
n2.next = NULL; <span class="cmt">// n2 is the end of the list</span></code></pre>
                        <p class="text-gray-700 mt-4"><strong>Note:</strong> A structure cannot contain an *instance* of itself (e.g., <code class="font-mono text-sm bg-gray-100 p-1 rounded">struct Node n;</code>) as a member, as this would create an infinitely recursive definition. It must be a *pointer*.</p>
                    </div>
                </div>
            </section>

            <!-- Section: Unions -->
            <section id="unions" class="scroll-mt-20">
                <h2 class="text-2xl sm:text-3xl font-bold text-gray-900 border-b-2 border-indigo-500 pb-2 mb-6">2. Unions</h2>
                
                <div class="space-y-6">
                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is a union in C?</h3>
                        <div class="prose text-gray-700">
                            <p>A union is a user-defined data type, syntactically similar to a structure. The key difference is in memory allocation: a union's members <strong>all share the same memory location</strong>. </p>
                            <p>This means a union can only store a value for <strong>one of its members at any given time</strong>. The size of the union is determined by the size of its <strong>largest member</strong>. Think of it as a single box that can hold *either* a 4-byte integer *or* a 1-byte character, but not both. The box itself must be 4 bytes wide to accommodate the integer.</p>
                            <p><strong>Use Case:</strong> Unions are used to save memory in situations where you need to store a value that can be one of several different types, but never at the same time. This is common in "variant records" or in low-level, memory-constrained systems.</p>
                        </div>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is the key difference between a structure and a union?</h3>
                        <div class="prose text-gray-700">
                            <p>The fundamental difference is <strong>memory management</strong>.</p>
                            <ul>
                                <li><strong>Structure (struct):</strong> Allocates separate memory for <strong>all</strong> its members. Total size is the sum of all member sizes (plus alignment padding).</li>
                                <li><strong>Union:</strong> Allocates a <strong>single, shared</strong> block of memory for all its members. Total size is the size of its <strong>largest</strong> member.</li>
                            </ul>
                            <p>This leads to a critical difference in behavior:</p>
                            <ul>
                                <li>In a <strong>structure</strong>, you can store and access all members simultaneously.</li>
                                <li>In a <strong>union</strong>, storing a value in one member will <strong>overwrite</strong> (corrupt) the data that was previously stored in any other member.</li>
                            <li><strong>Union:</strong> Allocates memory equal to the size of its <strong>largest</strong> member. All members overlay each other in this single memory space.</li>
                        </ul>
                        <pre><code><span class="kw">struct</span> MyStruct {
    <span class="kw">int</span> i;    <span class="cmt">// 4 bytes (e.g., at address 1000)</span>
    <span class="kw">char</span> c;   <span class="cmt">// 1 byte (e.g., at address 1004)</span>
}; <span class="cmt">// Total Size: 8 bytes (4 for int + 1 for char + 3 padding)</span>

<span class="kw">union</span> MyUnion {
    <span class="kw">int</span> i;    <span class="cmt">// 4 bytes (e.g., at address 2000)</span>
    <span class="kw">char</span> c;   <span class="cmt">// 1 byte (e.g., at address 2000)</span>
}; <span class="cmt">// Total Size: 4 bytes (size of largest member, int)</span>

<span class="cmt">// Behavior Demonstration</span>
<span class="kw">union</span> MyUnion u;
u.i = <span class="num">65</span>; <span class="cmt">// Store an integer. Memory (binary): 00...01000001</span>
printf(<span class="str">"Integer: %d\n"</span>, u.i);  <span class="cmt">// Prints 65</span>
printf(<span class="str">"Character: %c\n"</span>, u.c); <span class="cmt">// Prints 'A' (ASCII 65)</span>

u.c = <span class="str">'B'</span>; <span class="cmt">// Now store a character (overwrites the int)</span>
printf(<span class="str">"Character: %c\n"</span>, u.c); <span class="cmt">// Prints 'B' (ASCII 66)</span>
printf(<span class="str">"Integer: %d\n"</span>, u.i);  <span class="cmt">// Prints 66 (or garbage). The value of 'i' has been</span>
                    <span class="cmt">// partially or fully overwritten by the write to 'c'.</span></code></pre>
                        <p class="text-gray-700 mt-4"><strong>Warning:</strong> Accessing a member that was not the one most recently written to leads to undefined behavior (though it can be used for advanced type-punning).</p>
                    </div>
                    
                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What are the main use cases for a union?</h3>
                        <p class="text-gray-700 mb-4">Unions are used in specific scenarios:</p>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li><strong>Memory Saving:</strong> When you need to store data that can be one of several types, but <strong>never at the same time</strong>. For example, a "value" in a data packet could be a 4-byte integer OR a 4-byte float, but not both. A union avoids allocating 8 bytes when only 4 are ever needed.</li>
                            <li><strong>Type Punning:</strong> A low-level programming technique to interpret the bits of one data type as another. For example, inspecting the raw bits of a <code class="font-mono text-sm bg-gray-100 p-1 rounded">float</code> by storing it in a union and reading it as an <code class="font-mono text-sm bg-gray-100 p-1 rounded">int</code>. This is advanced and can be non-portable.</li>
                        </ul>
                        <pre><code><span class="cmt">// Use case: A 'generic' data type</span>
<span class="kw">enum</span> DataType { IS_INT, IS_FLOAT, IS_CHAR };

<span class="kw">struct</span> Value {
    <span class="kw">enum</span> DataType type;
    <span class="kw">union</span> {
        <span class="kw">int</span> i;
        <span class="kw">float</span> f;
        <span class="kw">char</span> c;
    } data; <span class="cmt">// All members share the same memory</span>
};

<span class="cmt">// 'Value' can hold an int, float, or char, and 'type'</span>
<span class="cmt">// tells us which one is currently active.</span>
<span class="kw">struct</span> Value v;
v.type = IS_INT;
v.data.i = <span class="num">100</span>;</code></pre>
                    </div>
                </div>
            </section>

                        <span class="kw">int</span> r = (<span class="num">5</span> * <span class="num">5</span>);
<span class="kw">int</span> m = ((<span class="num">10</span>) > (<span class="num">20</span>) ? (<span class="num">10</span>) : (<span class="num">20</span>));</code></pre>
                        <p class="text-gray-700 mt-4"><strong>Note:</strong> Always use parentheses <code class="font-mono text-sm bg-gray-100 p-1 rounded">()</code> generously in macros to avoid operator precedence errors.</p>
                        
                        <p class="text-gray-700 font-semibold mt-4 mb-2">Pitfalls of Function-like Macros:</p>
                        <p class="text-gray-700 mb-4">Macros perform blind text substitution, which can have unexpected side effects, especially with increment/decrement operators.</p>
                        <pre><code>#define SQUARE(x) (x * x)

<span class="kw">int</span> a = <span class="num">4</span>;
<span class="kw">int</span> b = SQUARE(a++); <span class="cmt">// a++ is an expression with a side effect</span>

<span class="cmt">// Preprocessor expands this to:</span>
<span class="kw">int</span> b = (a++ * a++);

<span class="cmt">// This invokes undefined behavior! The compiler might</span>
<span class="cmt">// evaluate it as (4 * 5) or (5 * 4) or (4 * 4). 'a' is</span>
<span class="cmt">// incremented twice. This is a famous bug.</span>
<span class="cmt">// A true function 'int square(int x)' would evaluate a++</span>
<span class="cmt">// once (passing 4), return 16, and a would become 5.</span></code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is macro substitution?</h3>
                        <div class="prose text-gray-700">
                            <p>Macro substitution (<code class="font-mono text-sm bg-gray-100 p-1 rounded">#define</code>) is a directive that instructs the preprocessor to perform a "find and replace" operation on the source code. It associates an identifier (the macro name) with a replacement token string.</p>
                            
                            <p><strong>1. Object-like Macros (Symbolic Constants):</strong>
                                <br>Replaces an identifier with a constant value. This is preferred over "magic numbers" (like <code class="font-mono text-sm bg-gray-100 p-1 rounded">3.14159</code>) because it makes the code more readable and easier to maintain (you only need to change the value in one <code class="font-mono text-sm bg-gray-100 p-1 rounded">#define</code>).
                            </p>
                        </div>
                        <pre><code>#define PI <span class="num">3.14159</span>
#define MAX_STUDENTS <span class="num">60</span>

<span class="cmt">// --- Preprocessor sees this: ---</span>
<span class="kw">float</span> area = PI * r * r;
<span class="kw">int</span> bca_class[MAX_STUDENTS];

<span class="cmt">// --- Compiler sees this (after preprocessing): ---</span>
<span class="kw">float</span> area = <span class="num">3.14159</span> * r * r;
<span class="kw">int</span> bca_class[<span class="num">60</span>];</code></pre>

                        <div class="prose text-gray-700 mt-4">
                            <p><strong>2. Function-like Macros (with arguments):</strong>
                                <br>These macros take arguments, similar to functions. They can be faster than functions for very simple operations because they avoid the "function call overhead" (stack setup, branching). However, they are dangerous and must be written with extreme care.
                            </p>
                        </div>
                        <pre><code><span class="cmt">// Note the heavy use of parentheses to avoid operator precedence errors</span>
#define SQUARE(x) ((x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))

                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li><code class="font-mono text-sm bg-gray-100 p-1 rounded">#include &lt;filename.h&gt;</code>: Used for <strong>system header files</strong> (standard library). The preprocessor searches in standard system directories (e.g., <code class="font-mono text-sm">/usr/include</code>) where compiler-provided headers are stored.</li>
                            <li><code class="font-mono text-sm bg-gray-100 p-1 rounded">#include "filename.h"</code>: Used for <strong>user-defined header files</strong> (your own headers). The preprocessor first searches in the <strong>current directory</strong> (where your source file is) and then, if not found, searches the standard system directories.</li>
                        </ul>
                    </div>
                    
                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: What is conditional compilation?</h3>
                        <p class="text-gray-700 mb-4">Conditional compilation directives allow you to include or exclude parts of your code from compilation based on certain conditions. This is extremely useful for writing code that runs on different operating systems, for debugging, or for creating different versions of a program (e.g., "demo" vs. "full" version).</p>
                        <p class="text-gray-700 mb-2">The main directives are <code class="font-mono text-sm bg-gray-100 p-1 rounded">#if</code>, <code class="font-mono text-sm bg-gray-100 p-1 rounded">#else</code>, <code class="font-mono text-sm bg-gray-100 p-1 rounded">#elif</code>, and <code class="font-mono text-sm bg-gray-100 p-1 rounded">#endif</code>.</p>
                        <pre><code><span class="cmt">// Example 1: Debugging messages</span>
#define DEBUG <span class="num">1</span>

<span class="kw">int</span> main() {
    #if DEBUG == <span class="num">1</span>
        printf(<span class="str">"Debug: main function started.\n"</span>);
    #endif

    <span class="cmt">// ... rest of code ...</span>
}</code></pre>
                        
                        <p class="text-gray-700 mb-2 mt-4">A very common use is checking if a macro is defined at all, using <code class="font-mono text-sm bg-gray-100 p-1 rounded">#ifdef</code> (if defined) and <code class="font-mono text-sm bg-gray-100 p-1 rounded">#ifndef</code> (if not defined).</p>
                        <pre><code><span class="cmt">// Example 2: "Include guards" in header files</span>
<span class="cmt">// This is a standard pattern in all .h files to</span>
<span class="cmt">// prevent errors from including the same file twice.</span>

#ifndef MY_HEADER_FILE_H  <span class="cmt">// If this macro is NOT defined...</span>
#define MY_HEADER_FILE_H  <span class="cmt">// ...then define it.</span>

<span class="cmt">// ... all your struct definitions and function prototypes ...</span>
<span class="kw">struct</span> MyStruct { ... };
<span class="kw">void</span> myFunction();

#endif <span class="cmt">// End of the #ifndef block</span>

<span class="cmt">// The first time this file is included, MY_HEADER_FILE_H</span>
<span class="cmt">// is undefined, so the code is included and the macro is defined.</span>
<span class="cmt">// The second time, MY_HEADER_FILE_H *is* defined, so</span>
<span class="cmt">// the preprocessor skips the entire file.</span></code></pre>
                    </div>

                    <!-- Q&A Card -->
                    <div class="bg-white p-6 rounded-lg shadow-md transition-shadow duration-300 hover:shadow-lg">
                        <h3 class="text-lg font-semibold text-indigo-700 mb-2">Q: Are there other important preprocessor directives?</h3>
                        <p class="text-gray-700 mb-4">Yes, a few others are common:</p>
                        <ul class="list-disc list-inside space-y-2 text-gray-700">
                            <li><code class="font-mono text-sm bg-gray-100 p-1 rounded">#undef</code>: This "undefines" a macro that was previously defined. <br><code class="font-mono text-xs bg-gray-100 p-1 rounded ml-6">#undef DEBUG</code></li>
                            <li><code class="font-mono text-sm bg-gray-100 p-1 rounded">#pragma</code>: Used to issue special, non-standard commands to the compiler. Its behavior is compiler-specific. A common one is <code class="font-mono text-sm bg-gray-100 p-1 rounded">#pragma once</code>, which is a simpler (but non-standard) alternative to include guards.</li>
                            <li><code class="font-mono text-sm bg-gray-100 p-1 rounded">#error</code>: Tells the preprocessor to stop and output an error message. <br><code class="font-mono text-xs bg-gray-100 p-1 rounded ml-6">#error This feature is not supported.</code></li>
                        </ul>
                    </div>
                </div>
            </section>

        </main>
    </div>

</body>
</html>


