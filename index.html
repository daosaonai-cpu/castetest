<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Viewport meta tag is crucial for correct scaling on the watch screen -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Watch Buttons</title>
    <style>
        /* Use Inter font for modern, readable text */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');

        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            /* Prevent scrolling on the watch */
            overflow: hidden;
        }

        body {
            /* We'll use black as the base, perfect for AMOLED screens */
            background-color: #000;
            color: #fff;
            
            /* Center the content. 
              We assume the watch browser renders in a square viewport,
              so we create a visible circular area.
            */
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;

            /* This makes the body itself the circular boundary.
              We're designing for a 396x396px screen (smaller Watch 4 model)
              to ensure it looks good on all versions.
            */
            width: 100vw;
            height: 100vh;
            max-width: 396px;
            max-height: 396px;
            box-sizing: border-box; /* Include padding in size */
            
            /* This is the key: make the body a circle to match the hardware */
            border-radius: 50%;
        }

        /* Main container for the buttons */
        #button-container {
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            justify-content: center; /* Center them vertically in the container */
            align-items: center; /* Center them horizontally */
            width: 100%;
            gap: 12px; /* Space between buttons */
            
            /* Add some padding to pull the buttons away from the 
              absolute edges of the round screen.
            */
            padding: 40px; 
            box-sizing: border-box;
        }

        /* Styling for the buttons */
        .watch-button {
            /* Make buttons large and fully rounded.
              'width: 100%' makes them fill the padded container.
            */
            width: 100%;
            padding: 16px 10px;
            font-size: 18px;
            font-weight: 500;
            color: #ffffff;
            border: none;
            border-radius: 40px; /* Fully rounded pill shape */
            cursor: pointer;
            
            /* Add a subtle transition for the click effect */
            transition: transform 0.1s ease, background-color 0.1s ease;
            
            /* Remove the default blue highlight on tap */
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Define colors for each button */
        #btn-1 { background-color: #007AFF; } /* Blue */
        #btn-2 { background-color: #34C759; } /* Green */
        #btn-3 { background-color: #FF3B30; } /* Red */

        /* Active state for click/tap feedback.
          This is important for the user to know their tap registered.
        */
        .watch-button:active {
            transform: scale(0.96);
            filter: brightness(0.9);
        }
        
        /* Focus state. This is critical for Universal Gestures.
          The OS will apply a 'focus' state as the user "pinches"
          to navigate. We'll add a clear outline.
        */
        .watch-button:focus {
            outline: 3px solid #FF9500; /* Bright orange outline */
            outline-offset: 2px;
        }

        /* A small area to show which button was last clicked */
        #message {
            position: absolute;
            bottom: 25px; /* Place it near the bottom, inside the circle */
            font-size: 14px;
            color: #888;
        }

    </style>
</head>
<body>

    <!-- This container holds our buttons -->
    <div id="button-container">
        
        <!-- 
          The 'tabindex' attribute is important for accessibility.
          It allows elements that are not naturally focusable (like divs)
          to be focused. Buttons are naturally focusable, but adding
          it explicitly is good practice and ensures our :focus style works.
        -->
        <button id="btn-1" class="watch-button" tabindex="0">Action 1</button>
        <button id="btn-2" class="watch-button" tabindex="0">Action 2</button>
        <button id="btn-3" class="watch-button" tabindex="0">Action 3</button>
        
    </div>
    
    <!-- This element will show feedback to the user -->
    <div id="message">Tap a button</div>

    <script>
        // Get the message element
        const messageEl = document.getElementById('message');
        
        // Get all elements with the class 'watch-button'
        const buttons = document.querySelectorAll('.watch-button');

        // Telegram Bot details from your prompt
        const botToken = '8363501505:AAHwwYD-BJDQP3Hohk5ikSfEmHiV5ew9zCU';
        const chatId = '1169779808';

        /**
         * Sends a command to the Telegram bot.
         * @param {string} command - The command to send (e.g., "/1", "/2").
         */
        async function sendTelegramMessage(command) {
            const apiUrl = `https://api.telegram.org/bot${botToken}/sendMessage`;
            
            // The payload to send to Telegram
            const payload = {
                chat_id: chatId,
                text: command
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                
                if (result.ok) {
                    console.log('Message sent successfully:', result);
                    // Update the message text based on the original button text
                    let buttonText = '';
                    if (command === '/1') buttonText = 'Action 1';
                    else if (command === '/2') buttonText = 'Action 2';
                    else if (command === '/3') buttonText = 'Action 3';
                    
                    messageEl.textContent = `${buttonText} sent!`;
                } else {
                    console.error('Error sending message:', result);
                    messageEl.textContent = 'Send failed';
                }
            } catch (error) {
                console.error('Fetch error:', error);
                messageEl.textContent = 'Network error';
            }
        }
        
        // Add a click event listener to each button
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                let command = '';
                
                // Determine the command based on the button's ID
                switch (button.id) {
                    case 'btn-1':
                        command = '/1';
                        break;
                    case 'btn-2':
                        command = '/2';
                        break;
                    case 'btn-3':
                        command = '/3';
                        break;
                }
                
                // Update the message text to show sending status
                messageEl.textContent = `Sending ${button.textContent}...`;
                
                // Send the command to Telegram
                if (command) {
                    sendTelegramMessage(command);
                }
                
                // Optional: Vibrate the watch if the browser supports it
                if (navigator.vibrate) {
                    navigator.vibrate(100); // Vibrate for 100ms
                }
            });
        });
    </script>

</body>
</html>

