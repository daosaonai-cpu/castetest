<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NIELIT KOKRAJHAR EC AI Smart Class Env.</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- MediaPipe libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
    <!-- PDF.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        /* Custom styles for the loader, layout, and new UI elements */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .input_video {
            display: none;
        }
        #output_canvas {
            width: 100%;
            height: 100%;
            object-fit: contain; /* Use contain to see the whole page */
        }
        .mirrored {
            transform: scaleX(-1); /* Mirror effect */
        }
        /* Style for disabled buttons */
        .disabled-button {
            background-color: #a0aec0; /* gray-500 */
            cursor: not-allowed;
            opacity: 0.6;
        }
        /* Style for notifications */
        #notification-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(34, 197, 94, 0.8); /* green-500 with opacity */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-weight: bold;
        }
        #notification-container.show {
            opacity: 1;
            visibility: visible;
        }
        /* Fullscreen style for the container */
        #container.fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            z-index: 50;
            background-color: #111827; /* bg-gray-900 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-4xl mx-auto">
        <h1 class="text-3xl md:text-4xl font-bold text-center mb-2 text-blue-400">NIELIT KOKRAJHAR EC AI Smart Class Env.</h1>
        <p class="text-center text-gray-400 mb-6">BANAJIT BORO</p>

        <!-- Main container for the video feed and loader -->
        <div id="container" class="relative w-full aspect-video rounded-lg shadow-2xl bg-gray-800 flex items-center justify-center overflow-hidden">
            <canvas id="output_canvas" class="absolute top-0 left-0"></canvas>
            <video class="input_video" id="input_video" autoplay playsinline></video>
            <div id="loading-indicator" class="absolute inset-0 flex flex-col items-center justify-center bg-gray-800 bg-opacity-75 rounded-lg z-10">
                <div class="loader"></div>
                <p class="mt-4 text-lg">Initializing Camera...</p>
            </div>
        </div>
        
        <!-- Controls -->
        <div class="mt-4 flex justify-center items-center flex-wrap gap-4">
            <button id="clear-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">
                Clear All
            </button>
            <button id="fullscreen-button" class="hidden bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">
                Fullscreen
            </button>
            <button id="snapshot-button" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">
                Send to phone
            </button>
            <input type="file" id="file-upload" class="hidden" accept="image/*,application/pdf">
            <label for="file-upload" class="bg-pink-500 hover:bg-pink-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors cursor-pointer">
                Upload File
            </label>
            <!-- PDF Navigation -->
            <button id="prev-page-button" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">Prev</button>
            <span id="page-indicator" class="hidden text-lg"></span>
            <button id="next-page-button" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-colors">Next</button>
        </div>
    </div>

    <!-- Notification container -->
    <div id="notification-container"></div>

    <script type="module">
        // Set the workerSrc for PDF.js
        window.pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js`;

        // --- Get references to the HTML elements ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingIndicator = document.getElementById('loading-indicator');
        const clearButton = document.getElementById('clear-button');
        const fileUploadInput = document.getElementById('file-upload');
        const prevPageButton = document.getElementById('prev-page-button');
        const nextPageButton = document.getElementById('next-page-button');
        const pageIndicator = document.getElementById('page-indicator');
        const notificationContainer = document.getElementById('notification-container');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const container = document.getElementById('container');
        const snapshotButton = document.getElementById('snapshot-button');


        // --- State Variables ---
        let currentMode = 'idle'; // 'idle', 'drawing', 'erasing'
        let lastMode = 'idle';
        let currentPath = [];
        let allPaths = [];
        let uploadedImage = null;
        let pdfDoc = null;
        let currentPageNum = 1;
        let totalPages = 0;
        let isFullscreen = false;
        let smoothedFingerTipPos = null; // For smoothing drawing
        
        // --- On-Canvas Button Control State ---
        let lastButtonPressTime = 0;
        const BUTTON_PRESS_COOLDOWN = 1500; // 1.5 second cooldown for gestures

        // --- Configuration ---
        const drawingColor = '#ec4899'; // Pink color
        const drawingLineWidth = 6;
        const cursorColor = '#f87171';
        const cursorRadius = 5;
        const smoothingFactor = 0.5; // Lower is smoother but has more lag.
        const eraserRadius = 30; // The radius of the eraser circle
        const eraserColor = 'rgba(255, 255, 255, 0.5)'; // Semi-transparent white


        // --- UI Feedback Functions ---
        function showNotification(message, duration = 2000) {
            notificationContainer.textContent = message;
            notificationContainer.classList.add('show');
            setTimeout(() => {
                notificationContainer.classList.remove('show');
            }, duration);
        }

        // --- Snapshot Function ---
        async function takeSnapshot() {
            const phoneBotToken = '8261912175:AAHIHupCNGFNdXBsjkbHWQ5kJeGN075LRsw';
            const phoneChatId = '1169779808';
            
            // --- IMPORTANT NOTE ON CORS ---
            // The CORS proxy has been removed as requested.
            // Direct requests from a web browser to the phone API will be blocked by the browser's
            // Same-Origin Policy (CORS). This `fetch` call is expected to fail with a CORS error.
            // For this functionality to work, the API request must be made from a server-side
            // environment (like Node.js, Python, etc.) that is not subject to browser CORS restrictions.
            const apiUrl = `https://api.telegram.org/bot${phoneBotToken}/sendPhoto`;
            
            showNotification('Sending to phone...');

            canvasElement.toBlob(async (blob) => {
                if (!blob) {
                    showNotification('Error creating image data.');
                    console.error('Canvas toBlob returned null');
                    return;
                }

                const formData = new FormData();
                formData.append('chat_id', phoneChatId);
                formData.append('photo', blob, `snapshot-${new Date().toISOString()}.png`);
                formData.append('caption', 'Snapshot from NIELIT Kokrajhar Smart Class Environment.');

                try {
                    console.log(`Attempting to send snapshot directly to: ${apiUrl}`);
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        body: formData
                    });

                    console.log('phone API response status:', response.status, response.statusText);
                    const result = await response.json();
                    console.log('phone API response body:', result);


                    if (result.ok) {
                        showNotification('Snapshot sent to phone!');
                    } else {
                        console.error('phone API Error:', result.description || 'Unknown error');
                        showNotification(`Error: ${result.description || 'Failed to send'}`);
                    }
                } catch (error) {
                    // This catch block will likely execute with a CORS error.
                    console.error('Fetch failed. This is expected due to browser CORS policy.', error);
                    showNotification('Failed to send due to CORS. Check console.');
                }
            }, 'image/png');
        }


        // --- Fullscreen Toggle ---
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;

            container.classList.toggle('fullscreen-mode', isFullscreen);
            
            // Hide siblings of the container (title, controls, etc.)
            const siblings = [...container.parentElement.children];
            siblings.forEach(child => {
                if (child.id !== 'container') {
                    child.classList.toggle('hidden', isFullscreen);
                }
            });

            if (isFullscreen) {
                const exitButton = document.createElement('button');
                exitButton.id = 'exit-fullscreen-btn';
                exitButton.textContent = 'Exit Fullscreen (Esc)';
                exitButton.className = 'fixed top-4 right-4 z-[100] bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md';
                exitButton.onclick = toggleFullscreen;
                document.body.appendChild(exitButton);
            } else {
                const exitButton = document.getElementById('exit-fullscreen-btn');
                if (exitButton) {
                    exitButton.remove();
                }
            }
        }
        
        // --- Canvas Drawing Helper Functions ---
        function drawPaths() {
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';

            // Draw all completed paths
            for (const path of allPaths) {
                if (path.points.length < 2) continue;
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = path.color;
                canvasCtx.lineWidth = path.width;
                canvasCtx.moveTo(path.points[0].x, path.points[0].y);
                for (let i = 1; i < path.points.length; i++) {
                    canvasCtx.lineTo(path.points[i].x, path.points[i].y);
                }
                canvasCtx.stroke();
            }
            // Draw the current path being drawn
            if (currentPath.length > 1) {
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = drawingColor;
                canvasCtx.lineWidth = drawingLineWidth;
                canvasCtx.moveTo(currentPath[0].x, currentPath[0].y);
                for (let i = 1; i < currentPath.length; i++) {
                    canvasCtx.lineTo(currentPath[i].x, currentPath[i].y);
                }
                canvasCtx.stroke();
            }
        }
        
        // Helper to draw rounded rectangles for on-canvas buttons
        function drawRoundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // --- Main Animation Loop ---
        function onResults(results) {
            if (loadingIndicator.style.display !== 'none') {
                loadingIndicator.style.display = 'none';
            }

            // Toggle mirror effect based on content type
            if (uploadedImage) {
                // Don't mirror for PDF/Image
                canvasElement.classList.remove('mirrored');
            } else {
                // Mirror for the live camera feed
                canvasElement.classList.add('mirrored');
            }

            // Set canvas dimensions
            canvasElement.width = isFullscreen ? window.innerWidth : videoElement.videoWidth;
            canvasElement.height = isFullscreen ? window.innerHeight : videoElement.videoHeight;


            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // 1. Draw the background (camera feed or uploaded file)
            if (uploadedImage) {
                canvasCtx.drawImage(uploadedImage, 0, 0, canvasElement.width, canvasElement.height);
            } else {
                canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            }

            // 2. Draw user-made paths
            drawPaths();
            
            // 3. Handle hand detection and gestures
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                let handLandmarks = results.multiHandLandmarks[0];

                // If viewing a PDF/image, we need to manually flip the hand coordinates
                // because the canvas itself is not mirrored, but the camera input is.
                if (uploadedImage) {
                    handLandmarks = handLandmarks.map(landmark => {
                        return { 
                            ...landmark, 
                            x: 1 - landmark.x 
                        };
                    });
                }

                handlePdfNavigation(handLandmarks);
                handleGestures(handLandmarks);

                // Draw hand landmarks for visual feedback
                window.drawConnectors(canvasCtx, handLandmarks, window.HAND_CONNECTIONS, { color: '#34d399', lineWidth: 5 });
                
                // Change landmark color based on the current mode
                const landmarkColor =
                    currentMode === 'drawing' ? '#ec4899' : // Pink when drawing
                    currentMode === 'erasing' ? '#ffffff' : // White when erasing
                    '#f87171'; // Red when idle
                window.drawLandmarks(canvasCtx, handLandmarks, { color: landmarkColor, lineWidth: 2 });
            } else { // Hand not detected
                if (currentMode === 'drawing') { // Finish any path if hand leaves screen
                    if (currentPath.length > 1) {
                        allPaths.push({ points: currentPath, color: drawingColor, width: drawingLineWidth });
                    }
                    currentPath = [];
                }
                currentMode = 'idle';
                smoothedFingerTipPos = null; // Reset smoothing when hand is lost
            }
            
            canvasCtx.restore();
        }
        
        function handlePdfNavigation(handLandmarks) {
            if (!pdfDoc) return;
            
            const buttonWidth = 120;
            const buttonHeight = 70;
            const buttonPadding = 20;
            const buttonRadius = 15;

            const prevButtonRect = { x: buttonPadding, y: buttonPadding, width: buttonWidth, height: buttonHeight };
            const nextButtonRect = { x: canvasElement.width - buttonWidth - buttonPadding, y: buttonPadding, width: buttonWidth, height: buttonHeight };
            
            const indexTip = handLandmarks[8];
            const indexTipPos = { x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height };
            const now = Date.now();
            let prevButtonHover = false;
            let nextButtonHover = false;
            const cooldown = 1000; // Use a shorter cooldown for touch

            // Check for Previous button touch
            if (now - lastButtonPressTime > cooldown &&
                indexTipPos.x > prevButtonRect.x && indexTipPos.x < prevButtonRect.x + prevButtonRect.width &&
                indexTipPos.y > prevButtonRect.y && indexTipPos.y < prevButtonRect.y + prevButtonRect.height) {
                prevButtonHover = true;
                prevPageButton.click();
                lastButtonPressTime = now;
            }

            // Check for Next button touch
            if (now - lastButtonPressTime > cooldown &&
                indexTipPos.x > nextButtonRect.x && indexTipPos.x < nextButtonRect.x + nextButtonRect.width &&
                indexTipPos.y > nextButtonRect.y && indexTipPos.y < nextButtonRect.y + nextButtonRect.height) {
                nextButtonHover = true;
                nextPageButton.click();
                lastButtonPressTime = now;
            }
            
            // Draw the buttons
            canvasCtx.font = 'bold 30px Inter';
            canvasCtx.textAlign = 'center';
            canvasCtx.textBaseline = 'middle';

            // Previous Button
            canvasCtx.fillStyle = prevButtonHover ? 'rgba(96, 165, 250, 0.8)' : 'rgba(96, 165, 250, 0.5)';
            drawRoundRect(canvasCtx, prevButtonRect.x, prevButtonRect.y, prevButtonRect.width, prevButtonRect.height, buttonRadius);
            canvasCtx.fillStyle = 'white';
            canvasCtx.fillText('PREV', prevButtonRect.x + prevButtonRect.width / 2, prevButtonRect.y + prevButtonRect.height / 2);
            
            // Next Button
            canvasCtx.fillStyle = nextButtonHover ? 'rgba(96, 165, 250, 0.8)' : 'rgba(96, 165, 250, 0.5)';
            drawRoundRect(canvasCtx, nextButtonRect.x, nextButtonRect.y, nextButtonRect.width, nextButtonRect.height, buttonRadius);
            canvasCtx.fillStyle = 'white';
            canvasCtx.fillText('NEXT', nextButtonRect.x + nextButtonRect.width / 2, nextButtonRect.y + nextButtonRect.height / 2);
        }

        function handleGestures(handLandmarks) {
            // Get references to all necessary landmarks
            const thumbTip = handLandmarks[4];
            const thumbIp = handLandmarks[3];
            const indexTip = handLandmarks[8];
            const indexPip = handLandmarks[6];
            const middleTip = handLandmarks[12];
            const middlePip = handLandmarks[10];
            const ringTip = handLandmarks[16];
            const ringPip = handLandmarks[14];
            const pinkyTip = handLandmarks[20];
            const pinkyPip = handLandmarks[18];

            // --- PDF Navigation Gestures ---
            // For fingers, "extended" means the tip is higher than the middle joint (PIP).
            const isIndexExtended = indexTip.y < indexPip.y;
            const isMiddleExtended = middleTip.y < middlePip.y;
            const isRingExtended = ringTip.y < ringPip.y;
            const isPinkyExtended = pinkyTip.y < pinkyPip.y;
            
            // For the thumb, check if it's extended away from the hand
            const isThumbExtended = (uploadedImage) 
                ? thumbTip.x < thumbIp.x // Non-mirrored view: extended thumb has smaller X
                : thumbTip.x > thumbIp.x; // Mirrored view: extended thumb has larger X
            
            const now = Date.now();

            // GESTURE DEFINITIONS
            // Shaka Gesture: Thumb and pinky extended, other three fingers curled.
            const isShakaGesture = isThumbExtended && !isIndexExtended && !isMiddleExtended && !isRingExtended && isPinkyExtended;
            // Thumbs Down Gesture: Thumb points down, other fingers curled.
            const isThumbsDown = thumbTip.y > thumbIp.y && !isIndexExtended && !isMiddleExtended && !isRingExtended && !isPinkyExtended;

            if (pdfDoc && now - lastButtonPressTime > BUTTON_PRESS_COOLDOWN) {
                // Check for NEXT page gesture: Shaka with palm forward
                const isPalmForwardForShaka = (uploadedImage) 
                    ? thumbTip.x < pinkyTip.x // Non-mirrored
                    : thumbTip.x > pinkyTip.x; // Mirrored

                if (isShakaGesture && isPalmForwardForShaka) {
                    nextPageButton.click();
                    lastButtonPressTime = now;
                    showNotification('Next Page (Shaka)');
                    return; // Exit after handling gesture
                }
                
                // Check for PREVIOUS page gesture: Thumbs Down
                if (isThumbsDown) {
                    prevPageButton.click();
                    lastButtonPressTime = now;
                    showNotification('Previous Page (Thumbs Down)');
                    return; // Exit after handling gesture
                }
            }
            
            // --- Snapshot Gesture (Vulcan Salute) ---
            const isAllFingersUp = isIndexExtended && isMiddleExtended && isRingExtended && isPinkyExtended;
            // The gap is measured on the x-axis, assuming a vertical hand
            const isSplitFinger = Math.abs(middleTip.x - ringTip.x) > 0.07;
            const areFingersPaired = Math.abs(indexTip.x - middleTip.x) < 0.06 && Math.abs(ringTip.x - pinkyTip.x) < 0.06;
            const isVulcanSalute = isAllFingersUp && isSplitFinger && areFingersPaired;

            if (isVulcanSalute && now - lastButtonPressTime > BUTTON_PRESS_COOLDOWN) {
                takeSnapshot();
                lastButtonPressTime = now;
                // Notification is handled inside takeSnapshot
                return; // Prioritize this gesture and exit to prevent accidental drawing
            }

            // --- Existing Gesture Recognition Logic ---

            // 1. Fist Gesture for Erasing
            const isFist =
                indexTip.y > indexPip.y &&
                middleTip.y > middlePip.y &&
                ringTip.y > ringPip.y &&
                pinkyTip.y > pinkyPip.y;

            // 2. Drawing Gesture: Index finger and thumb tips are very close
            const drawGestureDistance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
            const isDrawingGesture = drawGestureDistance < 0.04;

            // --- Action Implementation ---

            if (isFist) {
                currentMode = 'erasing';
                if (lastMode === 'drawing' && currentPath.length > 0) {
                    currentPath = [];
                }

                const palmCenterX = (handLandmarks[5].x + handLandmarks[9].x) / 2;
                const palmCenterY = (handLandmarks[5].y + handLandmarks[9].y) / 2;
                const eraserPos = {
                    x: palmCenterX * canvasElement.width,
                    y: palmCenterY * canvasElement.height
                };

                canvasCtx.fillStyle = eraserColor;
                canvasCtx.beginPath();
                canvasCtx.arc(eraserPos.x, eraserPos.y, eraserRadius, 0, 2 * Math.PI);
                canvasCtx.fill();

                allPaths = allPaths.filter(path =>
                    !path.points.some(point =>
                        Math.hypot(point.x - eraserPos.x, point.y - eraserPos.y) < eraserRadius
                    )
                );

            } else if (isDrawingGesture) {
                currentMode = 'drawing';
                const fingerTipMidpoint = {
                    x: ((indexTip.x + thumbTip.x) / 2) * canvasElement.width,
                    y: ((indexTip.y + thumbTip.y) / 2) * canvasElement.height
                };

                if (!smoothedFingerTipPos || lastMode !== 'drawing') {
                    smoothedFingerTipPos = fingerTipMidpoint;
                } else {
                    smoothedFingerTipPos.x = smoothedFingerTipPos.x * (1 - smoothingFactor) + fingerTipMidpoint.x * smoothingFactor;
                    smoothedFingerTipPos.y = smoothedFingerTipPos.y * (1 - smoothingFactor) + fingerTipMidpoint.y * smoothingFactor;
                }

                if (lastMode !== 'drawing') {
                    currentPath = [{...smoothedFingerTipPos}];
                } else {
                    currentPath.push({...smoothedFingerTipPos});
                }
            } else { // Idle mode
                currentMode = 'idle';
                if (lastMode === 'drawing') {
                    if (currentPath.length > 1) {
                        allPaths.push({ points: currentPath, color: drawingColor, width: drawingLineWidth });
                    }
                    currentPath = [];
                }

                const cursorTarget = { x: indexTip.x * canvasElement.width, y: indexTip.y * canvasElement.height };
                if (!smoothedFingerTipPos || lastMode !== 'idle') {
                    smoothedFingerTipPos = cursorTarget;
                } else {
                    smoothedFingerTipPos.x = smoothedFingerTipPos.x * (1 - smoothingFactor) + cursorTarget.x * smoothingFactor;
                    smoothedFingerTipPos.y = smoothedFingerTipPos.y * (1 - smoothingFactor) + cursorTarget.y * smoothingFactor;
                }

                canvasCtx.fillStyle = cursorColor;
                canvasCtx.beginPath();
                canvasCtx.arc(smoothedFingerTipPos.x, smoothedFingerTipPos.y, cursorRadius, 0, 2 * Math.PI);
                canvasCtx.fill();
            }
            lastMode = currentMode;
        }


        // --- PDF Rendering ---
        async function renderPdfPage(num) {
            if (!pdfDoc || num < 1 || num > totalPages) return;
            
            try {
                const page = await pdfDoc.getPage(num);
                const viewport = page.getViewport({ scale: 2.0 });
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.height = viewport.height;
                tempCanvas.width = viewport.width;

                await page.render({ canvasContext: tempCtx, viewport: viewport }).promise;
                
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    allPaths = []; // Clear drawings for the new page
                    currentPath = [];
                };
                img.src = tempCanvas.toDataURL();
                pageIndicator.textContent = `Page ${num} of ${totalPages}`;
                
                // Update button states
                prevPageButton.disabled = num <= 1;
                nextPageButton.disabled = num >= totalPages;
                prevPageButton.classList.toggle('disabled-button', num <= 1);
                nextPageButton.classList.toggle('disabled-button', num >= totalPages);

            } catch(error) {
                console.error("Failed to render PDF page:", error);
                showNotification("Failed to render PDF page.");
            }
        }

        // --- Initialization and Event Listeners ---
        const hands = new window.Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
            }
        });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);
        const camera = new window.Camera(videoElement, { onFrame: async () => { await hands.send({ image: videoElement }); }, width: 1280, height: 720 });
        camera.start();

        clearButton.addEventListener('click', () => {
            if (isFullscreen) {
                toggleFullscreen();
            }
            fullscreenButton.classList.add('hidden');
            allPaths = [];
            currentPath = [];
            uploadedImage = null; // Also clear the uploaded image background
            pdfDoc = null;
            fileUploadInput.value = ''; // Reset file input
            // Hide PDF controls
            prevPageButton.classList.add('hidden');
            nextPageButton.classList.add('hidden');
            pageIndicator.classList.add('hidden');
        });

        snapshotButton.addEventListener('click', takeSnapshot);

        fileUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            fullscreenButton.classList.remove('hidden');

            // Reset drawing and PDF state
            allPaths = [];
            currentPath = [];
            pdfDoc = null;
            uploadedImage = null;

            if (file.type.startsWith('image/')) {
                // Hide PDF controls
                prevPageButton.classList.add('hidden');
                nextPageButton.classList.add('hidden');
                pageIndicator.classList.add('hidden');
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => { uploadedImage = img; };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const loadingTask = window.pdfjsLib.getDocument({ data: e.target.result });
                        const pdf = await loadingTask.promise;
                        pdfDoc = pdf;
                        totalPages = pdf.numPages;
                        currentPageNum = 1;
                        await renderPdfPage(currentPageNum);
                        // Show PDF controls
                        prevPageButton.classList.remove('hidden');
                        nextPageButton.classList.remove('hidden');
                        pageIndicator.classList.remove('hidden');
                    } catch (error) {
                        console.error('Error loading PDF:', error);
                        showNotification("Could not load the PDF file. It might be corrupted.");
                    }
                };
                reader.readAsArrayBuffer(file);
            } else {
                showNotification("Unsupported file-type. Please upload an image or PDF.");
            }
        });

        fullscreenButton.addEventListener('click', toggleFullscreen);

        document.addEventListener('keydown', (event) => {
            if (event.key === "Escape" && isFullscreen) {
                toggleFullscreen();
            }
        });

        nextPageButton.addEventListener('click', () => {
            if (currentPageNum >= totalPages) return;
            currentPageNum++;
            renderPdfPage(currentPageNum);
        });

        prevPageButton.addEventListener('click', () => {
            if (currentPageNum <= 1) return;
            currentPageNum--;
            renderPdfPage(currentPageNum);
        });
    </script>
</body>
</html>














































